import { assertEquals } from "@std/assert/equals";
import {
	check_constraints,
	is_board_solved,
	new_board,
	print_board,
} from "./board.ts";
import type { Board } from "./board.ts";
import { dfs_prune } from "./dfs_prune.ts";
import { assert } from "@std/assert/assert";

const first_soln = [
	1,
	2,
	3,
	4,
	5,
	6,
	7,
	8,
	9,
	4,
	5,
	6,
	7,
	8,
	9,
	1,
	2,
	3,
	7,
	8,
	9,
	1,
	2,
	3,
	4,
	5,
	6,
	2,
	1,
	4,
	3,
	6,
	5,
	8,
	9,
	7,
	3,
	6,
	5,
	8,
	9,
	7,
	2,
	1,
	4,
	8,
	9,
	7,
	2,
	1,
	4,
	3,
	6,
	5,
	5,
	3,
	1,
	6,
	4,
	2,
	9,
	7,
	8,
	6,
	4,
	2,
	9,
	7,
	8,
	5,
	3,
	1,
	9,
	7,
	8,
	5,
	3,
	1,
	6,
	4,
	2,
];

const nyt_hardest_sudoku = [
	8,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	3,
	6,
	0,
	0,
	0,
	0,
	0,
	0,
	7,
	0,
	0,
	9,
	0,
	2,
	0,
	0,
	0,
	5,
	0,
	0,
	0,
	7,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	4,
	5,
	7,
	0,
	0,
	0,
	0,
	0,
	1,
	0,
	0,
	0,
	3,
	0,
	0,
	0,
	1,
	0,
	0,
	0,
	0,
	6,
	8,
	0,
	0,
	8,
	5,
	0,
	0,
	0,
	1,
	0,
	0,
	9,
	0,
	0,
	0,
	0,
	4,
	0,
	0,
];

Deno.test("Returns expected solution", () => {
	const solns = dfs_prune(new_board(), 1, false);
	assertEquals(solns.length, 1, "Should only return one solution");
	assertEquals(solns[0], first_soln);
});

Deno.test("Is able to respond with random boards", () => {
	const solns = dfs_prune(new_board(), 1, true);
	assertEquals(solns.length, 1);
	assert(check_constraints(solns[0]));
	assert(is_board_solved(solns[0]));
});

Deno.test("Is able to create many solutions", () => {
	const solns = dfs_prune(new_board(), 1, true);
	for (const s of solns) {
		assert(is_board_solved(s));
	}
});

Deno.test("Gives unique solution for board with unique solution.", () => {
	// This will search the entire solution space since we ask for
	// 1000 solutions even though there is just one.
	const solns = dfs_prune(nyt_hardest_sudoku as Board, 1000, true);
	assertEquals(
		solns.length,
		1,
		"Ensure it only returns the unique solution and nothing else",
	);
});
